import { JaegerClient } from '../client';
import { FindTracesResponse } from '../domain';
import { Tool } from './types';

import { z } from 'zod';
import { Server } from '@modelcontextprotocol/sdk/server/index.js';

export class FindTraces implements Tool {
    name(): string {
        return 'find-traces';
    }

    description(): string {
        return 'Searches the spans as JSON array of object in the OpenTelemetry resource spans format';
    }

    paramsSchema() {
        return {
            serviceName: z
                .string()
                .describe('Filters spans generated by a specific service.'),
            operationName: z
                .string()
                .describe(
                    'Filters spans by a specific operation / span name (Optional).'
                )
                .optional(),
            attributes: z
                .record(z.string(), z.string().or(z.number().or(z.boolean())))
                .describe(
                    'Filters spans by span attributes. ' +
                        'Attributes can be passed in key/value format in JSON where ' +
                        'keys can be string and values can be string, number (integer or double) or boolean. \n' +
                        'For example: \n' +
                        '{' +
                        '\n' +
                        '\t' +
                        '"stringAttribute": "str"' +
                        ',' +
                        '\n' +
                        '\t' +
                        '"integerAttribute": 123' +
                        ',' +
                        '\n' +
                        '\t' +
                        '"doubleAttribute": 123.456' +
                        ',' +
                        '\n' +
                        '\t' +
                        '"booleanAttribute": true' +
                        '\n' +
                        '}'
                )
                .optional(),
            startTimeMin: z
                .string()
                .datetime()
                .describe(
                    'Start of the time interval (inclusive) for the query. ' +
                        'Only traces with spans that started on or after this time will be returned. ' +
                        'The HTTP API uses RFC 3339, section 5.6 format (e.g., "2017-07-21T17:32:28Z").'
                ),
            startTimeMax: z
                .string()
                .datetime()
                .describe(
                    'End of the time interval (exclusive) for the query. ' +
                        'Only traces with spans that started before this time will be returned. ' +
                        'The HTTP API uses RFC 3339, section 5.6 format (e.g., "2017-07-21T17:32:28Z").'
                ),
            durationMin: z
                .number()
                .positive()
                .describe(
                    'Minimum duration of a span in milliseconds in the trace. ' +
                        'Only traces with spans that lasted at least this long will be returned (Optional). '
                )
                .optional(),
            durationMax: z
                .number()
                .positive()
                .describe(
                    'Maximum duration of a span in milliseconds in the trace. ' +
                        'Only traces with spans that lasted at most this long will be returned (Optional).'
                )
                .optional(),
            searchDepth: z
                .number()
                .positive()
                .describe(
                    'Defines the maximum search depth. ' +
                        'Depending on the backend storage implementation, this may behave like an SQL `LIMIT` clause. ' +
                        'However, some implementations might not support precise limits, ' +
                        'and a larger value generally results in more traces being returned (Optional).'
                )
                .optional(),
        };
    }

    private _normalizeAttributes(
        attributes: Map<string, string | number | boolean>
    ): { [k: string]: string } {
        const normalizedAttributes: { [k: string]: string } = {};
        if (attributes) {
            for (let [key, value] of Object.entries(attributes)) {
                normalizedAttributes[key] = value.toString();
            }
        }
        return normalizedAttributes;
    }

    async handle(
        server: Server,
        jaegerClient: JaegerClient,
        {
            serviceName,
            operationName,
            attributes,
            startTimeMin,
            startTimeMax,
            durationMin,
            durationMax,
            searchDepth,
        }: any
    ): Promise<string> {
        const response: FindTracesResponse = await jaegerClient.findTraces({
            query: {
                serviceName,
                operationName,
                attributes: this._normalizeAttributes(attributes),
                startTimeMin: Date.parse(startTimeMin),
                startTimeMax: Date.parse(startTimeMax),
                durationMin,
                durationMax,
                searchDepth,
            },
        });
        return JSON.stringify(response.resourceSpans || {});
    }
}
